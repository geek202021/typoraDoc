#  Typora的使用

[Typora的使用-GitHub](https://github.com/younghz/Markdown)

[Typora的使用-CSDN](https://blog.csdn.net/weixin_39751195/article/details/109971095)

[中文文案排版指南](https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md)

[程序员鱼皮](https://www.code-nav.cn/resources)     [Java学习路线by-yupi](https://doc.code-nav.cn/roadmap/java)

- 段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用**两个以上**空格加上回车（引用中换行省略回车）。
- 在段落的每行或者只在第一行使用符号`>`,还可使用多个嵌套引用，如：\> 区块引用 \>> 嵌套引用
- 在强调内容两侧分别加上`*`或者`_`，如：*斜体*   **粗体**  ~~删除线的内容~~ 或按快捷键Alt+Shift+5
- **分割线**最常使用就是三个或以上`*`，还可以使用`-`和`_`和+。**【回车】**
- 符号`: 起到标记作用。如： :`` ctrl+a``
- []() 行内式链接  ；
- Ctrl + F 搜索 ；Ctrl + H 替换
- **使用表情** : + 表情单词(| 注意，英文冒号之后紧跟一个单词，支持智能提示)
- **插入代码块**\``` + 对应编程语种

>常用文本编辑快捷键：

- home键：光标回到行首；end：光标回到行尾
- ctrl + home键：光标回到文章开始；ctrl + end键：光标回到文章末尾
- shift + home 或 end 键：选中一行
- 鼠标双击：选中一个单词 / 鼠标连续击3次：选中一行
- ctrl+ shift + 右箭头或左箭头：选中一个单词
- ctrl + f ：查找

---

#  基础知识

1. 标识符： 0-9、a-z、$、_ 
2. 引用数据类型：数组、类、接口。
3. **%:**任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。
4.   **&** **和 &&区别：** & ：无论左边结果是什么，右边都参与运算。
   1. **&&:短路与**，如果左边为false，那么右边不参数与运算。
5. **|** **和|| 区别：**|：两边都运算。
   1. ||：短路或，如果左边为true，那么右边不参与运算。
6. 当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为**标号**。
7. 如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。
8. **重载**的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。当函数同名时，只看参数列表。和返回值类型没关系。
9. 寄存器、本地方法区。方法区。栈、堆
10. 主函数的解释：保证所在类的独立运行，是程序的入口，被 JVM 调用。
11. 成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。
12. **构造函数**：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。
    1. 记住：所有对象创建时，都需要初始化才可以使用。
    2. **注意事项：**一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。
13. 构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。|  而 构造函数：是给与之对应的对象进行初始化。它具有针对性。
14. this:代表对象。就是所在函数所属对象的引用。
15. 静态随着类的加载而加载。而且优先于对象存在。
    1. 静态方法只能访问静态成员，不可以访问非静态成员。因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。
    2. **静态方法中不能使用this，super关键字。**因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。
    3. 定义成员时，到底需不需要被静态修饰呢？如果没有访问过特有数据，那么这个方法需要被静态修饰。
16. 成员变量存在于堆内存中。静态变量存在于方法区中。成员变量随着对象创建而存在。随着对象被回收而消失。静态变量随着类的加载而存在。随着类的消失而消失。成员变量只能被对象所调用 。
    1. **成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。**
17. **静态代码块：****如果和主函数在同一类中，优先于主函数执行。**
18. jvm调用main方法时，传递的实际参数是 new String[0]。
19. 静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块 > 构造代码块 >构造函数；
20. 单例模式：1.私有化类的构造器、2.创建私有并静态的本类对象、3.提供公共的静态方法，返回类的对象
21. 子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。
    1. 当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：**覆盖(复写，重写)**
22. 发现子类构造函数运行时，先运行了父类的构造函数。原因：子类的**所有构造函数中的第一行**，其实都有一条隐身的语句super();
    1. 如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。
    2. 子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。

##   抽象类

1. 抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。
2. 抽象类不可以被创建对象(实例化)。只有通过子类**继承**抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。
3. 抽象关键字abstract和哪些不可以共存？private , final ,static。 抽象方法目的仅仅为了不让该类创建对象。

##  接口

1. 成员变量：public static final 、成员方法：public abstract 
2. 接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。

##  多态

1. 多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)
2. ``instanceof`` ;//判断对象是否实现了指定的接口或继承了指定的类
